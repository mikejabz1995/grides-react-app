{"ast":null,"code":"import{rectToClientRect,autoPlacement as autoPlacement$1,shift as shift$1,flip as flip$1,size as size$1,hide as hide$1,arrow as arrow$1,inline as inline$1,limitShift as limitShift$1,computePosition as computePosition$1}from'@floating-ui/core';export{detectOverflow,offset}from'@floating-ui/core';import{round,createCoords,max,min,floor}from'@floating-ui/utils';import{getComputedStyle,isHTMLElement,isElement,getWindow,isWebKit,getDocumentElement,getNodeName,isOverflowElement,getNodeScroll,getOverflowAncestors,getParentNode,isLastTraversableNode,isContainingBlock,isTableElement,getContainingBlock}from'@floating-ui/utils/dom';export{getOverflowAncestors}from'@floating-ui/utils/dom';function getCssDimensions(element){const css=getComputedStyle(element);// In testing environments, the `width` and `height` properties are empty\n// strings for SVG elements, returning NaN. Fallback to `0` in this case.\nlet width=parseFloat(css.width)||0;let height=parseFloat(css.height)||0;const hasOffset=isHTMLElement(element);const offsetWidth=hasOffset?element.offsetWidth:width;const offsetHeight=hasOffset?element.offsetHeight:height;const shouldFallback=round(width)!==offsetWidth||round(height)!==offsetHeight;if(shouldFallback){width=offsetWidth;height=offsetHeight;}return{width,height,$:shouldFallback};}function unwrapElement(element){return!isElement(element)?element.contextElement:element;}function getScale(element){const domElement=unwrapElement(element);if(!isHTMLElement(domElement)){return createCoords(1);}const rect=domElement.getBoundingClientRect();const{width,height,$}=getCssDimensions(domElement);let x=($?round(rect.width):rect.width)/width;let y=($?round(rect.height):rect.height)/height;// 0, NaN, or Infinity should always fallback to 1.\nif(!x||!Number.isFinite(x)){x=1;}if(!y||!Number.isFinite(y)){y=1;}return{x,y};}const noOffsets=/*#__PURE__*/createCoords(0);function getVisualOffsets(element){const win=getWindow(element);if(!isWebKit()||!win.visualViewport){return noOffsets;}return{x:win.visualViewport.offsetLeft,y:win.visualViewport.offsetTop};}function shouldAddVisualOffsets(element,isFixed,floatingOffsetParent){if(isFixed===void 0){isFixed=false;}if(!floatingOffsetParent||isFixed&&floatingOffsetParent!==getWindow(element)){return false;}return isFixed;}function getBoundingClientRect(element,includeScale,isFixedStrategy,offsetParent){if(includeScale===void 0){includeScale=false;}if(isFixedStrategy===void 0){isFixedStrategy=false;}const clientRect=element.getBoundingClientRect();const domElement=unwrapElement(element);let scale=createCoords(1);if(includeScale){if(offsetParent){if(isElement(offsetParent)){scale=getScale(offsetParent);}}else{scale=getScale(element);}}const visualOffsets=shouldAddVisualOffsets(domElement,isFixedStrategy,offsetParent)?getVisualOffsets(domElement):createCoords(0);let x=(clientRect.left+visualOffsets.x)/scale.x;let y=(clientRect.top+visualOffsets.y)/scale.y;let width=clientRect.width/scale.x;let height=clientRect.height/scale.y;if(domElement){const win=getWindow(domElement);const offsetWin=offsetParent&&isElement(offsetParent)?getWindow(offsetParent):offsetParent;let currentWin=win;let currentIFrame=currentWin.frameElement;while(currentIFrame&&offsetParent&&offsetWin!==currentWin){const iframeScale=getScale(currentIFrame);const iframeRect=currentIFrame.getBoundingClientRect();const css=getComputedStyle(currentIFrame);const left=iframeRect.left+(currentIFrame.clientLeft+parseFloat(css.paddingLeft))*iframeScale.x;const top=iframeRect.top+(currentIFrame.clientTop+parseFloat(css.paddingTop))*iframeScale.y;x*=iframeScale.x;y*=iframeScale.y;width*=iframeScale.x;height*=iframeScale.y;x+=left;y+=top;currentWin=getWindow(currentIFrame);currentIFrame=currentWin.frameElement;}}return rectToClientRect({width,height,x,y});}const topLayerSelectors=[':popover-open',':modal'];function isTopLayer(floating){return topLayerSelectors.some(selector=>{try{return floating.matches(selector);}catch(e){return false;}});}function convertOffsetParentRelativeRectToViewportRelativeRect(_ref){let{elements,rect,offsetParent,strategy}=_ref;const isFixed=strategy==='fixed';const documentElement=getDocumentElement(offsetParent);const topLayer=elements?isTopLayer(elements.floating):false;if(offsetParent===documentElement||topLayer&&isFixed){return rect;}let scroll={scrollLeft:0,scrollTop:0};let scale=createCoords(1);const offsets=createCoords(0);const isOffsetParentAnElement=isHTMLElement(offsetParent);if(isOffsetParentAnElement||!isOffsetParentAnElement&&!isFixed){if(getNodeName(offsetParent)!=='body'||isOverflowElement(documentElement)){scroll=getNodeScroll(offsetParent);}if(isHTMLElement(offsetParent)){const offsetRect=getBoundingClientRect(offsetParent);scale=getScale(offsetParent);offsets.x=offsetRect.x+offsetParent.clientLeft;offsets.y=offsetRect.y+offsetParent.clientTop;}}return{width:rect.width*scale.x,height:rect.height*scale.y,x:rect.x*scale.x-scroll.scrollLeft*scale.x+offsets.x,y:rect.y*scale.y-scroll.scrollTop*scale.y+offsets.y};}function getClientRects(element){return Array.from(element.getClientRects());}function getWindowScrollBarX(element){// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nreturn getBoundingClientRect(getDocumentElement(element)).left+getNodeScroll(element).scrollLeft;}// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element){const html=getDocumentElement(element);const scroll=getNodeScroll(element);const body=element.ownerDocument.body;const width=max(html.scrollWidth,html.clientWidth,body.scrollWidth,body.clientWidth);const height=max(html.scrollHeight,html.clientHeight,body.scrollHeight,body.clientHeight);let x=-scroll.scrollLeft+getWindowScrollBarX(element);const y=-scroll.scrollTop;if(getComputedStyle(body).direction==='rtl'){x+=max(html.clientWidth,body.clientWidth)-width;}return{width,height,x,y};}function getViewportRect(element,strategy){const win=getWindow(element);const html=getDocumentElement(element);const visualViewport=win.visualViewport;let width=html.clientWidth;let height=html.clientHeight;let x=0;let y=0;if(visualViewport){width=visualViewport.width;height=visualViewport.height;const visualViewportBased=isWebKit();if(!visualViewportBased||visualViewportBased&&strategy==='fixed'){x=visualViewport.offsetLeft;y=visualViewport.offsetTop;}}return{width,height,x,y};}// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element,strategy){const clientRect=getBoundingClientRect(element,true,strategy==='fixed');const top=clientRect.top+element.clientTop;const left=clientRect.left+element.clientLeft;const scale=isHTMLElement(element)?getScale(element):createCoords(1);const width=element.clientWidth*scale.x;const height=element.clientHeight*scale.y;const x=left*scale.x;const y=top*scale.y;return{width,height,x,y};}function getClientRectFromClippingAncestor(element,clippingAncestor,strategy){let rect;if(clippingAncestor==='viewport'){rect=getViewportRect(element,strategy);}else if(clippingAncestor==='document'){rect=getDocumentRect(getDocumentElement(element));}else if(isElement(clippingAncestor)){rect=getInnerBoundingClientRect(clippingAncestor,strategy);}else{const visualOffsets=getVisualOffsets(element);rect={...clippingAncestor,x:clippingAncestor.x-visualOffsets.x,y:clippingAncestor.y-visualOffsets.y};}return rectToClientRect(rect);}function hasFixedPositionAncestor(element,stopNode){const parentNode=getParentNode(element);if(parentNode===stopNode||!isElement(parentNode)||isLastTraversableNode(parentNode)){return false;}return getComputedStyle(parentNode).position==='fixed'||hasFixedPositionAncestor(parentNode,stopNode);}// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element,cache){const cachedResult=cache.get(element);if(cachedResult){return cachedResult;}let result=getOverflowAncestors(element,[],false).filter(el=>isElement(el)&&getNodeName(el)!=='body');let currentContainingBlockComputedStyle=null;const elementIsFixed=getComputedStyle(element).position==='fixed';let currentNode=elementIsFixed?getParentNode(element):element;// https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\nwhile(isElement(currentNode)&&!isLastTraversableNode(currentNode)){const computedStyle=getComputedStyle(currentNode);const currentNodeIsContaining=isContainingBlock(currentNode);if(!currentNodeIsContaining&&computedStyle.position==='fixed'){currentContainingBlockComputedStyle=null;}const shouldDropCurrentNode=elementIsFixed?!currentNodeIsContaining&&!currentContainingBlockComputedStyle:!currentNodeIsContaining&&computedStyle.position==='static'&&!!currentContainingBlockComputedStyle&&['absolute','fixed'].includes(currentContainingBlockComputedStyle.position)||isOverflowElement(currentNode)&&!currentNodeIsContaining&&hasFixedPositionAncestor(element,currentNode);if(shouldDropCurrentNode){// Drop non-containing blocks.\nresult=result.filter(ancestor=>ancestor!==currentNode);}else{// Record last containing block for next iteration.\ncurrentContainingBlockComputedStyle=computedStyle;}currentNode=getParentNode(currentNode);}cache.set(element,result);return result;}// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref){let{element,boundary,rootBoundary,strategy}=_ref;const elementClippingAncestors=boundary==='clippingAncestors'?getClippingElementAncestors(element,this._c):[].concat(boundary);const clippingAncestors=[...elementClippingAncestors,rootBoundary];const firstClippingAncestor=clippingAncestors[0];const clippingRect=clippingAncestors.reduce((accRect,clippingAncestor)=>{const rect=getClientRectFromClippingAncestor(element,clippingAncestor,strategy);accRect.top=max(rect.top,accRect.top);accRect.right=min(rect.right,accRect.right);accRect.bottom=min(rect.bottom,accRect.bottom);accRect.left=max(rect.left,accRect.left);return accRect;},getClientRectFromClippingAncestor(element,firstClippingAncestor,strategy));return{width:clippingRect.right-clippingRect.left,height:clippingRect.bottom-clippingRect.top,x:clippingRect.left,y:clippingRect.top};}function getDimensions(element){const{width,height}=getCssDimensions(element);return{width,height};}function getRectRelativeToOffsetParent(element,offsetParent,strategy){const isOffsetParentAnElement=isHTMLElement(offsetParent);const documentElement=getDocumentElement(offsetParent);const isFixed=strategy==='fixed';const rect=getBoundingClientRect(element,true,isFixed,offsetParent);let scroll={scrollLeft:0,scrollTop:0};const offsets=createCoords(0);if(isOffsetParentAnElement||!isOffsetParentAnElement&&!isFixed){if(getNodeName(offsetParent)!=='body'||isOverflowElement(documentElement)){scroll=getNodeScroll(offsetParent);}if(isOffsetParentAnElement){const offsetRect=getBoundingClientRect(offsetParent,true,isFixed,offsetParent);offsets.x=offsetRect.x+offsetParent.clientLeft;offsets.y=offsetRect.y+offsetParent.clientTop;}else if(documentElement){offsets.x=getWindowScrollBarX(documentElement);}}const x=rect.left+scroll.scrollLeft-offsets.x;const y=rect.top+scroll.scrollTop-offsets.y;return{x,y,width:rect.width,height:rect.height};}function getTrueOffsetParent(element,polyfill){if(!isHTMLElement(element)||getComputedStyle(element).position==='fixed'){return null;}if(polyfill){return polyfill(element);}return element.offsetParent;}// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element,polyfill){const window=getWindow(element);if(!isHTMLElement(element)||isTopLayer(element)){return window;}let offsetParent=getTrueOffsetParent(element,polyfill);while(offsetParent&&isTableElement(offsetParent)&&getComputedStyle(offsetParent).position==='static'){offsetParent=getTrueOffsetParent(offsetParent,polyfill);}if(offsetParent&&(getNodeName(offsetParent)==='html'||getNodeName(offsetParent)==='body'&&getComputedStyle(offsetParent).position==='static'&&!isContainingBlock(offsetParent))){return window;}return offsetParent||getContainingBlock(element)||window;}const getElementRects=async function(data){const getOffsetParentFn=this.getOffsetParent||getOffsetParent;const getDimensionsFn=this.getDimensions;return{reference:getRectRelativeToOffsetParent(data.reference,await getOffsetParentFn(data.floating),data.strategy),floating:{x:0,y:0,...(await getDimensionsFn(data.floating))}};};function isRTL(element){return getComputedStyle(element).direction==='rtl';}const platform={convertOffsetParentRelativeRectToViewportRelativeRect,getDocumentElement,getClippingRect,getOffsetParent,getElementRects,getClientRects,getDimensions,getScale,isElement,isRTL};// https://samthor.au/2021/observing-dom/\nfunction observeMove(element,onMove){let io=null;let timeoutId;const root=getDocumentElement(element);function cleanup(){var _io;clearTimeout(timeoutId);(_io=io)==null||_io.disconnect();io=null;}function refresh(skip,threshold){if(skip===void 0){skip=false;}if(threshold===void 0){threshold=1;}cleanup();const{left,top,width,height}=element.getBoundingClientRect();if(!skip){onMove();}if(!width||!height){return;}const insetTop=floor(top);const insetRight=floor(root.clientWidth-(left+width));const insetBottom=floor(root.clientHeight-(top+height));const insetLeft=floor(left);const rootMargin=-insetTop+\"px \"+-insetRight+\"px \"+-insetBottom+\"px \"+-insetLeft+\"px\";const options={rootMargin,threshold:max(0,min(1,threshold))||1};let isFirstUpdate=true;function handleObserve(entries){const ratio=entries[0].intersectionRatio;if(ratio!==threshold){if(!isFirstUpdate){return refresh();}if(!ratio){timeoutId=setTimeout(()=>{refresh(false,1e-7);},100);}else{refresh(false,ratio);}}isFirstUpdate=false;}// Older browsers don't support a `document` as the root and will throw an\n// error.\ntry{io=new IntersectionObserver(handleObserve,{...options,// Handle <iframe>s\nroot:root.ownerDocument});}catch(e){io=new IntersectionObserver(handleObserve,options);}io.observe(element);}refresh(true);return cleanup;}/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */function autoUpdate(reference,floating,update,options){if(options===void 0){options={};}const{ancestorScroll=true,ancestorResize=true,elementResize=typeof ResizeObserver==='function',layoutShift=typeof IntersectionObserver==='function',animationFrame=false}=options;const referenceEl=unwrapElement(reference);const ancestors=ancestorScroll||ancestorResize?[...(referenceEl?getOverflowAncestors(referenceEl):[]),...getOverflowAncestors(floating)]:[];ancestors.forEach(ancestor=>{ancestorScroll&&ancestor.addEventListener('scroll',update,{passive:true});ancestorResize&&ancestor.addEventListener('resize',update);});const cleanupIo=referenceEl&&layoutShift?observeMove(referenceEl,update):null;let reobserveFrame=-1;let resizeObserver=null;if(elementResize){resizeObserver=new ResizeObserver(_ref=>{let[firstEntry]=_ref;if(firstEntry&&firstEntry.target===referenceEl&&resizeObserver){// Prevent update loops when using the `size` middleware.\n// https://github.com/floating-ui/floating-ui/issues/1740\nresizeObserver.unobserve(floating);cancelAnimationFrame(reobserveFrame);reobserveFrame=requestAnimationFrame(()=>{var _resizeObserver;(_resizeObserver=resizeObserver)==null||_resizeObserver.observe(floating);});}update();});if(referenceEl&&!animationFrame){resizeObserver.observe(referenceEl);}resizeObserver.observe(floating);}let frameId;let prevRefRect=animationFrame?getBoundingClientRect(reference):null;if(animationFrame){frameLoop();}function frameLoop(){const nextRefRect=getBoundingClientRect(reference);if(prevRefRect&&(nextRefRect.x!==prevRefRect.x||nextRefRect.y!==prevRefRect.y||nextRefRect.width!==prevRefRect.width||nextRefRect.height!==prevRefRect.height)){update();}prevRefRect=nextRefRect;frameId=requestAnimationFrame(frameLoop);}update();return()=>{var _resizeObserver2;ancestors.forEach(ancestor=>{ancestorScroll&&ancestor.removeEventListener('scroll',update);ancestorResize&&ancestor.removeEventListener('resize',update);});cleanupIo==null||cleanupIo();(_resizeObserver2=resizeObserver)==null||_resizeObserver2.disconnect();resizeObserver=null;if(animationFrame){cancelAnimationFrame(frameId);}};}/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */const autoPlacement=autoPlacement$1;/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */const shift=shift$1;/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */const flip=flip$1;/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */const size=size$1;/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */const hide=hide$1;/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */const arrow=arrow$1;/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */const inline=inline$1;/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */const limitShift=limitShift$1;/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */const computePosition=(reference,floating,options)=>{// This caches the expensive `getClippingElementAncestors` function so that\n// multiple lifecycle resets re-use the same result. It only lives for a\n// single call. If other functions become expensive, we can add them as well.\nconst cache=new Map();const mergedOptions={platform,...options};const platformWithCache={...mergedOptions.platform,_c:cache};return computePosition$1(reference,floating,{...mergedOptions,platform:platformWithCache});};export{arrow,autoPlacement,autoUpdate,computePosition,flip,hide,inline,limitShift,platform,shift,size};","map":{"version":3,"names":["rectToClientRect","autoPlacement","autoPlacement$1","shift","shift$1","flip","flip$1","size","size$1","hide","hide$1","arrow","arrow$1","inline","inline$1","limitShift","limitShift$1","computePosition","computePosition$1","detectOverflow","offset","round","createCoords","max","min","floor","getComputedStyle","isHTMLElement","isElement","getWindow","isWebKit","getDocumentElement","getNodeName","isOverflowElement","getNodeScroll","getOverflowAncestors","getParentNode","isLastTraversableNode","isContainingBlock","isTableElement","getContainingBlock","getCssDimensions","element","css","width","parseFloat","height","hasOffset","offsetWidth","offsetHeight","shouldFallback","$","unwrapElement","contextElement","getScale","domElement","rect","getBoundingClientRect","x","y","Number","isFinite","noOffsets","getVisualOffsets","win","visualViewport","offsetLeft","offsetTop","shouldAddVisualOffsets","isFixed","floatingOffsetParent","includeScale","isFixedStrategy","offsetParent","clientRect","scale","visualOffsets","left","top","offsetWin","currentWin","currentIFrame","frameElement","iframeScale","iframeRect","clientLeft","paddingLeft","clientTop","paddingTop","topLayerSelectors","isTopLayer","floating","some","selector","matches","e","convertOffsetParentRelativeRectToViewportRelativeRect","_ref","elements","strategy","documentElement","topLayer","scroll","scrollLeft","scrollTop","offsets","isOffsetParentAnElement","offsetRect","getClientRects","Array","from","getWindowScrollBarX","getDocumentRect","html","body","ownerDocument","scrollWidth","clientWidth","scrollHeight","clientHeight","direction","getViewportRect","visualViewportBased","getInnerBoundingClientRect","getClientRectFromClippingAncestor","clippingAncestor","hasFixedPositionAncestor","stopNode","parentNode","position","getClippingElementAncestors","cache","cachedResult","get","result","filter","el","currentContainingBlockComputedStyle","elementIsFixed","currentNode","computedStyle","currentNodeIsContaining","shouldDropCurrentNode","includes","ancestor","set","getClippingRect","boundary","rootBoundary","elementClippingAncestors","_c","concat","clippingAncestors","firstClippingAncestor","clippingRect","reduce","accRect","right","bottom","getDimensions","getRectRelativeToOffsetParent","getTrueOffsetParent","polyfill","getOffsetParent","window","getElementRects","data","getOffsetParentFn","getDimensionsFn","reference","isRTL","platform","observeMove","onMove","io","timeoutId","root","cleanup","_io","clearTimeout","disconnect","refresh","skip","threshold","insetTop","insetRight","insetBottom","insetLeft","rootMargin","options","isFirstUpdate","handleObserve","entries","ratio","intersectionRatio","setTimeout","IntersectionObserver","observe","autoUpdate","update","ancestorScroll","ancestorResize","elementResize","ResizeObserver","layoutShift","animationFrame","referenceEl","ancestors","forEach","addEventListener","passive","cleanupIo","reobserveFrame","resizeObserver","firstEntry","target","unobserve","cancelAnimationFrame","requestAnimationFrame","_resizeObserver","frameId","prevRefRect","frameLoop","nextRefRect","_resizeObserver2","removeEventListener","Map","mergedOptions","platformWithCache"],"sources":["/Users/mikejabrhamdan/grides-react-app/src/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs"],"sourcesContent":["import { rectToClientRect, autoPlacement as autoPlacement$1, shift as shift$1, flip as flip$1, size as size$1, hide as hide$1, arrow as arrow$1, inline as inline$1, limitShift as limitShift$1, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { detectOverflow, offset } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getDocumentElement, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = currentWin.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = currentWin.frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nconst topLayerSelectors = [':popover-open', ':modal'];\nfunction isTopLayer(floating) {\n  return topLayerSelectors.some(selector => {\n    try {\n      return floating.matches(selector);\n    } catch (e) {\n      return false;\n    }\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  const x = rect.left + scroll.scrollLeft - offsets.x;\n  const y = rect.top + scroll.scrollTop - offsets.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n  if (!isHTMLElement(element) || isTopLayer(element)) {\n    return window;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      ...(await getDimensionsFn(data.floating))\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 100);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, flip, hide, inline, limitShift, platform, shift, size };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}