{"ast":null,"code":"import{getSideAxis,getAlignmentAxis,getAxisLength,getSide,getAlignment,evaluate,getPaddingObject,rectToClientRect,min,clamp,placements,getAlignmentSides,getOppositeAlignmentPlacement,getOppositePlacement,getExpandedPlacements,getOppositeAxisPlacements,sides,max,getOppositeAxis}from'@floating-ui/utils';export{rectToClientRect}from'@floating-ui/utils';function computeCoordsFromPlacement(_ref,placement,rtl){let{reference,floating}=_ref;const sideAxis=getSideAxis(placement);const alignmentAxis=getAlignmentAxis(placement);const alignLength=getAxisLength(alignmentAxis);const side=getSide(placement);const isVertical=sideAxis==='y';const commonX=reference.x+reference.width/2-floating.width/2;const commonY=reference.y+reference.height/2-floating.height/2;const commonAlign=reference[alignLength]/2-floating[alignLength]/2;let coords;switch(side){case'top':coords={x:commonX,y:reference.y-floating.height};break;case'bottom':coords={x:commonX,y:reference.y+reference.height};break;case'right':coords={x:reference.x+reference.width,y:commonY};break;case'left':coords={x:reference.x-floating.width,y:commonY};break;default:coords={x:reference.x,y:reference.y};}switch(getAlignment(placement)){case'start':coords[alignmentAxis]-=commonAlign*(rtl&&isVertical?-1:1);break;case'end':coords[alignmentAxis]+=commonAlign*(rtl&&isVertical?-1:1);break;}return coords;}/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */const computePosition=async(reference,floating,config)=>{const{placement='bottom',strategy='absolute',middleware=[],platform}=config;const validMiddleware=middleware.filter(Boolean);const rtl=await(platform.isRTL==null?void 0:platform.isRTL(floating));let rects=await platform.getElementRects({reference,floating,strategy});let{x,y}=computeCoordsFromPlacement(rects,placement,rtl);let statefulPlacement=placement;let middlewareData={};let resetCount=0;for(let i=0;i<validMiddleware.length;i++){const{name,fn}=validMiddleware[i];const{x:nextX,y:nextY,data,reset}=await fn({x,y,initialPlacement:placement,placement:statefulPlacement,strategy,middlewareData,rects,platform,elements:{reference,floating}});x=nextX!=null?nextX:x;y=nextY!=null?nextY:y;middlewareData={...middlewareData,[name]:{...middlewareData[name],...data}};if(reset&&resetCount<=50){resetCount++;if(typeof reset==='object'){if(reset.placement){statefulPlacement=reset.placement;}if(reset.rects){rects=reset.rects===true?await platform.getElementRects({reference,floating,strategy}):reset.rects;}({x,y}=computeCoordsFromPlacement(rects,statefulPlacement,rtl));}i=-1;}}return{x,y,placement:statefulPlacement,strategy,middlewareData};};/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */async function detectOverflow(state,options){var _await$platform$isEle;if(options===void 0){options={};}const{x,y,platform,rects,elements,strategy}=state;const{boundary='clippingAncestors',rootBoundary='viewport',elementContext='floating',altBoundary=false,padding=0}=evaluate(options,state);const paddingObject=getPaddingObject(padding);const altContext=elementContext==='floating'?'reference':'floating';const element=elements[altBoundary?altContext:elementContext];const clippingClientRect=rectToClientRect(await platform.getClippingRect({element:((_await$platform$isEle=await(platform.isElement==null?void 0:platform.isElement(element)))!=null?_await$platform$isEle:true)?element:element.contextElement||(await(platform.getDocumentElement==null?void 0:platform.getDocumentElement(elements.floating))),boundary,rootBoundary,strategy}));const rect=elementContext==='floating'?{...rects.floating,x,y}:rects.reference;const offsetParent=await(platform.getOffsetParent==null?void 0:platform.getOffsetParent(elements.floating));const offsetScale=(await(platform.isElement==null?void 0:platform.isElement(offsetParent)))?(await(platform.getScale==null?void 0:platform.getScale(offsetParent)))||{x:1,y:1}:{x:1,y:1};const elementClientRect=rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect?await platform.convertOffsetParentRelativeRectToViewportRelativeRect({elements,rect,offsetParent,strategy}):rect);return{top:(clippingClientRect.top-elementClientRect.top+paddingObject.top)/offsetScale.y,bottom:(elementClientRect.bottom-clippingClientRect.bottom+paddingObject.bottom)/offsetScale.y,left:(clippingClientRect.left-elementClientRect.left+paddingObject.left)/offsetScale.x,right:(elementClientRect.right-clippingClientRect.right+paddingObject.right)/offsetScale.x};}/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */const arrow=options=>({name:'arrow',options,async fn(state){const{x,y,placement,rects,platform,elements,middlewareData}=state;// Since `element` is required, we don't Partial<> the type.\nconst{element,padding=0}=evaluate(options,state)||{};if(element==null){return{};}const paddingObject=getPaddingObject(padding);const coords={x,y};const axis=getAlignmentAxis(placement);const length=getAxisLength(axis);const arrowDimensions=await platform.getDimensions(element);const isYAxis=axis==='y';const minProp=isYAxis?'top':'left';const maxProp=isYAxis?'bottom':'right';const clientProp=isYAxis?'clientHeight':'clientWidth';const endDiff=rects.reference[length]+rects.reference[axis]-coords[axis]-rects.floating[length];const startDiff=coords[axis]-rects.reference[axis];const arrowOffsetParent=await(platform.getOffsetParent==null?void 0:platform.getOffsetParent(element));let clientSize=arrowOffsetParent?arrowOffsetParent[clientProp]:0;// DOM platform can return `window` as the `offsetParent`.\nif(!clientSize||!(await(platform.isElement==null?void 0:platform.isElement(arrowOffsetParent)))){clientSize=elements.floating[clientProp]||rects.floating[length];}const centerToReference=endDiff/2-startDiff/2;// If the padding is large enough that it causes the arrow to no longer be\n// centered, modify the padding so that it is centered.\nconst largestPossiblePadding=clientSize/2-arrowDimensions[length]/2-1;const minPadding=min(paddingObject[minProp],largestPossiblePadding);const maxPadding=min(paddingObject[maxProp],largestPossiblePadding);// Make sure the arrow doesn't overflow the floating element if the center\n// point is outside the floating element's bounds.\nconst min$1=minPadding;const max=clientSize-arrowDimensions[length]-maxPadding;const center=clientSize/2-arrowDimensions[length]/2+centerToReference;const offset=clamp(min$1,center,max);// If the reference is small enough that the arrow's padding causes it to\n// to point to nothing for an aligned placement, adjust the offset of the\n// floating element itself. To ensure `shift()` continues to take action,\n// a single reset is performed when this is true.\nconst shouldAddOffset=!middlewareData.arrow&&getAlignment(placement)!=null&&center!==offset&&rects.reference[length]/2-(center<min$1?minPadding:maxPadding)-arrowDimensions[length]/2<0;const alignmentOffset=shouldAddOffset?center<min$1?center-min$1:center-max:0;return{[axis]:coords[axis]+alignmentOffset,data:{[axis]:offset,centerOffset:center-offset-alignmentOffset,...(shouldAddOffset&&{alignmentOffset})},reset:shouldAddOffset};}});function getPlacementList(alignment,autoAlignment,allowedPlacements){const allowedPlacementsSortedByAlignment=alignment?[...allowedPlacements.filter(placement=>getAlignment(placement)===alignment),...allowedPlacements.filter(placement=>getAlignment(placement)!==alignment)]:allowedPlacements.filter(placement=>getSide(placement)===placement);return allowedPlacementsSortedByAlignment.filter(placement=>{if(alignment){return getAlignment(placement)===alignment||(autoAlignment?getOppositeAlignmentPlacement(placement)!==placement:false);}return true;});}/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */const autoPlacement=function(options){if(options===void 0){options={};}return{name:'autoPlacement',options,async fn(state){var _middlewareData$autoP,_middlewareData$autoP2,_placementsThatFitOnE;const{rects,middlewareData,placement,platform,elements}=state;const{crossAxis=false,alignment,allowedPlacements=placements,autoAlignment=true,...detectOverflowOptions}=evaluate(options,state);const placements$1=alignment!==undefined||allowedPlacements===placements?getPlacementList(alignment||null,autoAlignment,allowedPlacements):allowedPlacements;const overflow=await detectOverflow(state,detectOverflowOptions);const currentIndex=((_middlewareData$autoP=middlewareData.autoPlacement)==null?void 0:_middlewareData$autoP.index)||0;const currentPlacement=placements$1[currentIndex];if(currentPlacement==null){return{};}const alignmentSides=getAlignmentSides(currentPlacement,rects,await(platform.isRTL==null?void 0:platform.isRTL(elements.floating)));// Make `computeCoords` start from the right place.\nif(placement!==currentPlacement){return{reset:{placement:placements$1[0]}};}const currentOverflows=[overflow[getSide(currentPlacement)],overflow[alignmentSides[0]],overflow[alignmentSides[1]]];const allOverflows=[...(((_middlewareData$autoP2=middlewareData.autoPlacement)==null?void 0:_middlewareData$autoP2.overflows)||[]),{placement:currentPlacement,overflows:currentOverflows}];const nextPlacement=placements$1[currentIndex+1];// There are more placements to check.\nif(nextPlacement){return{data:{index:currentIndex+1,overflows:allOverflows},reset:{placement:nextPlacement}};}const placementsSortedByMostSpace=allOverflows.map(d=>{const alignment=getAlignment(d.placement);return[d.placement,alignment&&crossAxis?// Check along the mainAxis and main crossAxis side.\nd.overflows.slice(0,2).reduce((acc,v)=>acc+v,0):// Check only the mainAxis.\nd.overflows[0],d.overflows];}).sort((a,b)=>a[1]-b[1]);const placementsThatFitOnEachSide=placementsSortedByMostSpace.filter(d=>d[2].slice(0,// Aligned placements should not check their opposite crossAxis\n// side.\ngetAlignment(d[0])?2:3).every(v=>v<=0));const resetPlacement=((_placementsThatFitOnE=placementsThatFitOnEachSide[0])==null?void 0:_placementsThatFitOnE[0])||placementsSortedByMostSpace[0][0];if(resetPlacement!==placement){return{data:{index:currentIndex+1,overflows:allOverflows},reset:{placement:resetPlacement}};}return{};}};};/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */const flip=function(options){if(options===void 0){options={};}return{name:'flip',options,async fn(state){var _middlewareData$arrow,_middlewareData$flip;const{placement,middlewareData,rects,initialPlacement,platform,elements}=state;const{mainAxis:checkMainAxis=true,crossAxis:checkCrossAxis=true,fallbackPlacements:specifiedFallbackPlacements,fallbackStrategy='bestFit',fallbackAxisSideDirection='none',flipAlignment=true,...detectOverflowOptions}=evaluate(options,state);// If a reset by the arrow was caused due to an alignment offset being\n// added, we should skip any logic now since `flip()` has already done its\n// work.\n// https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\nif((_middlewareData$arrow=middlewareData.arrow)!=null&&_middlewareData$arrow.alignmentOffset){return{};}const side=getSide(placement);const isBasePlacement=getSide(initialPlacement)===initialPlacement;const rtl=await(platform.isRTL==null?void 0:platform.isRTL(elements.floating));const fallbackPlacements=specifiedFallbackPlacements||(isBasePlacement||!flipAlignment?[getOppositePlacement(initialPlacement)]:getExpandedPlacements(initialPlacement));if(!specifiedFallbackPlacements&&fallbackAxisSideDirection!=='none'){fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement,flipAlignment,fallbackAxisSideDirection,rtl));}const placements=[initialPlacement,...fallbackPlacements];const overflow=await detectOverflow(state,detectOverflowOptions);const overflows=[];let overflowsData=((_middlewareData$flip=middlewareData.flip)==null?void 0:_middlewareData$flip.overflows)||[];if(checkMainAxis){overflows.push(overflow[side]);}if(checkCrossAxis){const sides=getAlignmentSides(placement,rects,rtl);overflows.push(overflow[sides[0]],overflow[sides[1]]);}overflowsData=[...overflowsData,{placement,overflows}];// One or more sides is overflowing.\nif(!overflows.every(side=>side<=0)){var _middlewareData$flip2,_overflowsData$filter;const nextIndex=(((_middlewareData$flip2=middlewareData.flip)==null?void 0:_middlewareData$flip2.index)||0)+1;const nextPlacement=placements[nextIndex];if(nextPlacement){// Try next placement and re-run the lifecycle.\nreturn{data:{index:nextIndex,overflows:overflowsData},reset:{placement:nextPlacement}};}// First, find the candidates that fit on the mainAxis side of overflow,\n// then find the placement that fits the best on the main crossAxis side.\nlet resetPlacement=(_overflowsData$filter=overflowsData.filter(d=>d.overflows[0]<=0).sort((a,b)=>a.overflows[1]-b.overflows[1])[0])==null?void 0:_overflowsData$filter.placement;// Otherwise fallback.\nif(!resetPlacement){switch(fallbackStrategy){case'bestFit':{var _overflowsData$map$so;const placement=(_overflowsData$map$so=overflowsData.map(d=>[d.placement,d.overflows.filter(overflow=>overflow>0).reduce((acc,overflow)=>acc+overflow,0)]).sort((a,b)=>a[1]-b[1])[0])==null?void 0:_overflowsData$map$so[0];if(placement){resetPlacement=placement;}break;}case'initialPlacement':resetPlacement=initialPlacement;break;}}if(placement!==resetPlacement){return{reset:{placement:resetPlacement}};}}return{};}};};function getSideOffsets(overflow,rect){return{top:overflow.top-rect.height,right:overflow.right-rect.width,bottom:overflow.bottom-rect.height,left:overflow.left-rect.width};}function isAnySideFullyClipped(overflow){return sides.some(side=>overflow[side]>=0);}/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */const hide=function(options){if(options===void 0){options={};}return{name:'hide',options,async fn(state){const{rects}=state;const{strategy='referenceHidden',...detectOverflowOptions}=evaluate(options,state);switch(strategy){case'referenceHidden':{const overflow=await detectOverflow(state,{...detectOverflowOptions,elementContext:'reference'});const offsets=getSideOffsets(overflow,rects.reference);return{data:{referenceHiddenOffsets:offsets,referenceHidden:isAnySideFullyClipped(offsets)}};}case'escaped':{const overflow=await detectOverflow(state,{...detectOverflowOptions,altBoundary:true});const offsets=getSideOffsets(overflow,rects.floating);return{data:{escapedOffsets:offsets,escaped:isAnySideFullyClipped(offsets)}};}default:{return{};}}}};};function getBoundingRect(rects){const minX=min(...rects.map(rect=>rect.left));const minY=min(...rects.map(rect=>rect.top));const maxX=max(...rects.map(rect=>rect.right));const maxY=max(...rects.map(rect=>rect.bottom));return{x:minX,y:minY,width:maxX-minX,height:maxY-minY};}function getRectsByLine(rects){const sortedRects=rects.slice().sort((a,b)=>a.y-b.y);const groups=[];let prevRect=null;for(let i=0;i<sortedRects.length;i++){const rect=sortedRects[i];if(!prevRect||rect.y-prevRect.y>prevRect.height/2){groups.push([rect]);}else{groups[groups.length-1].push(rect);}prevRect=rect;}return groups.map(rect=>rectToClientRect(getBoundingRect(rect)));}/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */const inline=function(options){if(options===void 0){options={};}return{name:'inline',options,async fn(state){const{placement,elements,rects,platform,strategy}=state;// A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n// ClientRect's bounds, despite the event listener being triggered. A\n// padding of 2 seems to handle this issue.\nconst{padding=2,x,y}=evaluate(options,state);const nativeClientRects=Array.from((await(platform.getClientRects==null?void 0:platform.getClientRects(elements.reference)))||[]);const clientRects=getRectsByLine(nativeClientRects);const fallback=rectToClientRect(getBoundingRect(nativeClientRects));const paddingObject=getPaddingObject(padding);function getBoundingClientRect(){// There are two rects and they are disjoined.\nif(clientRects.length===2&&clientRects[0].left>clientRects[1].right&&x!=null&&y!=null){// Find the first rect in which the point is fully inside.\nreturn clientRects.find(rect=>x>rect.left-paddingObject.left&&x<rect.right+paddingObject.right&&y>rect.top-paddingObject.top&&y<rect.bottom+paddingObject.bottom)||fallback;}// There are 2 or more connected rects.\nif(clientRects.length>=2){if(getSideAxis(placement)==='y'){const firstRect=clientRects[0];const lastRect=clientRects[clientRects.length-1];const isTop=getSide(placement)==='top';const top=firstRect.top;const bottom=lastRect.bottom;const left=isTop?firstRect.left:lastRect.left;const right=isTop?firstRect.right:lastRect.right;const width=right-left;const height=bottom-top;return{top,bottom,left,right,width,height,x:left,y:top};}const isLeftSide=getSide(placement)==='left';const maxRight=max(...clientRects.map(rect=>rect.right));const minLeft=min(...clientRects.map(rect=>rect.left));const measureRects=clientRects.filter(rect=>isLeftSide?rect.left===minLeft:rect.right===maxRight);const top=measureRects[0].top;const bottom=measureRects[measureRects.length-1].bottom;const left=minLeft;const right=maxRight;const width=right-left;const height=bottom-top;return{top,bottom,left,right,width,height,x:left,y:top};}return fallback;}const resetRects=await platform.getElementRects({reference:{getBoundingClientRect},floating:elements.floating,strategy});if(rects.reference.x!==resetRects.reference.x||rects.reference.y!==resetRects.reference.y||rects.reference.width!==resetRects.reference.width||rects.reference.height!==resetRects.reference.height){return{reset:{rects:resetRects}};}return{};}};};// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\nasync function convertValueToCoords(state,options){const{placement,platform,elements}=state;const rtl=await(platform.isRTL==null?void 0:platform.isRTL(elements.floating));const side=getSide(placement);const alignment=getAlignment(placement);const isVertical=getSideAxis(placement)==='y';const mainAxisMulti=['left','top'].includes(side)?-1:1;const crossAxisMulti=rtl&&isVertical?-1:1;const rawValue=evaluate(options,state);let{mainAxis,crossAxis,alignmentAxis}=typeof rawValue==='number'?{mainAxis:rawValue,crossAxis:0,alignmentAxis:null}:{mainAxis:0,crossAxis:0,alignmentAxis:null,...rawValue};if(alignment&&typeof alignmentAxis==='number'){crossAxis=alignment==='end'?alignmentAxis*-1:alignmentAxis;}return isVertical?{x:crossAxis*crossAxisMulti,y:mainAxis*mainAxisMulti}:{x:mainAxis*mainAxisMulti,y:crossAxis*crossAxisMulti};}/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */const offset=function(options){if(options===void 0){options=0;}return{name:'offset',options,async fn(state){var _middlewareData$offse,_middlewareData$arrow;const{x,y,placement,middlewareData}=state;const diffCoords=await convertValueToCoords(state,options);// If the placement is the same and the arrow caused an alignment offset\n// then we don't need to change the positioning coordinates.\nif(placement===((_middlewareData$offse=middlewareData.offset)==null?void 0:_middlewareData$offse.placement)&&(_middlewareData$arrow=middlewareData.arrow)!=null&&_middlewareData$arrow.alignmentOffset){return{};}return{x:x+diffCoords.x,y:y+diffCoords.y,data:{...diffCoords,placement}};}};};/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */const shift=function(options){if(options===void 0){options={};}return{name:'shift',options,async fn(state){const{x,y,placement}=state;const{mainAxis:checkMainAxis=true,crossAxis:checkCrossAxis=false,limiter={fn:_ref=>{let{x,y}=_ref;return{x,y};}},...detectOverflowOptions}=evaluate(options,state);const coords={x,y};const overflow=await detectOverflow(state,detectOverflowOptions);const crossAxis=getSideAxis(getSide(placement));const mainAxis=getOppositeAxis(crossAxis);let mainAxisCoord=coords[mainAxis];let crossAxisCoord=coords[crossAxis];if(checkMainAxis){const minSide=mainAxis==='y'?'top':'left';const maxSide=mainAxis==='y'?'bottom':'right';const min=mainAxisCoord+overflow[minSide];const max=mainAxisCoord-overflow[maxSide];mainAxisCoord=clamp(min,mainAxisCoord,max);}if(checkCrossAxis){const minSide=crossAxis==='y'?'top':'left';const maxSide=crossAxis==='y'?'bottom':'right';const min=crossAxisCoord+overflow[minSide];const max=crossAxisCoord-overflow[maxSide];crossAxisCoord=clamp(min,crossAxisCoord,max);}const limitedCoords=limiter.fn({...state,[mainAxis]:mainAxisCoord,[crossAxis]:crossAxisCoord});return{...limitedCoords,data:{x:limitedCoords.x-x,y:limitedCoords.y-y}};}};};/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */const limitShift=function(options){if(options===void 0){options={};}return{options,fn(state){const{x,y,placement,rects,middlewareData}=state;const{offset=0,mainAxis:checkMainAxis=true,crossAxis:checkCrossAxis=true}=evaluate(options,state);const coords={x,y};const crossAxis=getSideAxis(placement);const mainAxis=getOppositeAxis(crossAxis);let mainAxisCoord=coords[mainAxis];let crossAxisCoord=coords[crossAxis];const rawOffset=evaluate(offset,state);const computedOffset=typeof rawOffset==='number'?{mainAxis:rawOffset,crossAxis:0}:{mainAxis:0,crossAxis:0,...rawOffset};if(checkMainAxis){const len=mainAxis==='y'?'height':'width';const limitMin=rects.reference[mainAxis]-rects.floating[len]+computedOffset.mainAxis;const limitMax=rects.reference[mainAxis]+rects.reference[len]-computedOffset.mainAxis;if(mainAxisCoord<limitMin){mainAxisCoord=limitMin;}else if(mainAxisCoord>limitMax){mainAxisCoord=limitMax;}}if(checkCrossAxis){var _middlewareData$offse,_middlewareData$offse2;const len=mainAxis==='y'?'width':'height';const isOriginSide=['top','left'].includes(getSide(placement));const limitMin=rects.reference[crossAxis]-rects.floating[len]+(isOriginSide?((_middlewareData$offse=middlewareData.offset)==null?void 0:_middlewareData$offse[crossAxis])||0:0)+(isOriginSide?0:computedOffset.crossAxis);const limitMax=rects.reference[crossAxis]+rects.reference[len]+(isOriginSide?0:((_middlewareData$offse2=middlewareData.offset)==null?void 0:_middlewareData$offse2[crossAxis])||0)-(isOriginSide?computedOffset.crossAxis:0);if(crossAxisCoord<limitMin){crossAxisCoord=limitMin;}else if(crossAxisCoord>limitMax){crossAxisCoord=limitMax;}}return{[mainAxis]:mainAxisCoord,[crossAxis]:crossAxisCoord};}};};/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */const size=function(options){if(options===void 0){options={};}return{name:'size',options,async fn(state){const{placement,rects,platform,elements}=state;const{apply=()=>{},...detectOverflowOptions}=evaluate(options,state);const overflow=await detectOverflow(state,detectOverflowOptions);const side=getSide(placement);const alignment=getAlignment(placement);const isYAxis=getSideAxis(placement)==='y';const{width,height}=rects.floating;let heightSide;let widthSide;if(side==='top'||side==='bottom'){heightSide=side;widthSide=alignment===((await(platform.isRTL==null?void 0:platform.isRTL(elements.floating)))?'start':'end')?'left':'right';}else{widthSide=side;heightSide=alignment==='end'?'top':'bottom';}const overflowAvailableHeight=height-overflow[heightSide];const overflowAvailableWidth=width-overflow[widthSide];const noShift=!state.middlewareData.shift;let availableHeight=overflowAvailableHeight;let availableWidth=overflowAvailableWidth;if(isYAxis){const maximumClippingWidth=width-overflow.left-overflow.right;availableWidth=alignment||noShift?min(overflowAvailableWidth,maximumClippingWidth):maximumClippingWidth;}else{const maximumClippingHeight=height-overflow.top-overflow.bottom;availableHeight=alignment||noShift?min(overflowAvailableHeight,maximumClippingHeight):maximumClippingHeight;}if(noShift&&!alignment){const xMin=max(overflow.left,0);const xMax=max(overflow.right,0);const yMin=max(overflow.top,0);const yMax=max(overflow.bottom,0);if(isYAxis){availableWidth=width-2*(xMin!==0||xMax!==0?xMin+xMax:max(overflow.left,overflow.right));}else{availableHeight=height-2*(yMin!==0||yMax!==0?yMin+yMax:max(overflow.top,overflow.bottom));}}await apply({...state,availableWidth,availableHeight});const nextDimensions=await platform.getDimensions(elements.floating);if(width!==nextDimensions.width||height!==nextDimensions.height){return{reset:{rects:true}};}return{};}};};export{arrow,autoPlacement,computePosition,detectOverflow,flip,hide,inline,limitShift,offset,shift,size};","map":{"version":3,"names":["getSideAxis","getAlignmentAxis","getAxisLength","getSide","getAlignment","evaluate","getPaddingObject","rectToClientRect","min","clamp","placements","getAlignmentSides","getOppositeAlignmentPlacement","getOppositePlacement","getExpandedPlacements","getOppositeAxisPlacements","sides","max","getOppositeAxis","computeCoordsFromPlacement","_ref","placement","rtl","reference","floating","sideAxis","alignmentAxis","alignLength","side","isVertical","commonX","x","width","commonY","y","height","commonAlign","coords","computePosition","config","strategy","middleware","platform","validMiddleware","filter","Boolean","isRTL","rects","getElementRects","statefulPlacement","middlewareData","resetCount","i","length","name","fn","nextX","nextY","data","reset","initialPlacement","elements","detectOverflow","state","options","_await$platform$isEle","boundary","rootBoundary","elementContext","altBoundary","padding","paddingObject","altContext","element","clippingClientRect","getClippingRect","isElement","contextElement","getDocumentElement","rect","offsetParent","getOffsetParent","offsetScale","getScale","elementClientRect","convertOffsetParentRelativeRectToViewportRelativeRect","top","bottom","left","right","arrow","axis","arrowDimensions","getDimensions","isYAxis","minProp","maxProp","clientProp","endDiff","startDiff","arrowOffsetParent","clientSize","centerToReference","largestPossiblePadding","minPadding","maxPadding","min$1","center","offset","shouldAddOffset","alignmentOffset","centerOffset","getPlacementList","alignment","autoAlignment","allowedPlacements","allowedPlacementsSortedByAlignment","autoPlacement","_middlewareData$autoP","_middlewareData$autoP2","_placementsThatFitOnE","crossAxis","detectOverflowOptions","placements$1","undefined","overflow","currentIndex","index","currentPlacement","alignmentSides","currentOverflows","allOverflows","overflows","nextPlacement","placementsSortedByMostSpace","map","d","slice","reduce","acc","v","sort","a","b","placementsThatFitOnEachSide","every","resetPlacement","flip","_middlewareData$arrow","_middlewareData$flip","mainAxis","checkMainAxis","checkCrossAxis","fallbackPlacements","specifiedFallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","flipAlignment","isBasePlacement","push","overflowsData","_middlewareData$flip2","_overflowsData$filter","nextIndex","_overflowsData$map$so","getSideOffsets","isAnySideFullyClipped","some","hide","offsets","referenceHiddenOffsets","referenceHidden","escapedOffsets","escaped","getBoundingRect","minX","minY","maxX","maxY","getRectsByLine","sortedRects","groups","prevRect","inline","nativeClientRects","Array","from","getClientRects","clientRects","fallback","getBoundingClientRect","find","firstRect","lastRect","isTop","isLeftSide","maxRight","minLeft","measureRects","resetRects","convertValueToCoords","mainAxisMulti","includes","crossAxisMulti","rawValue","_middlewareData$offse","diffCoords","shift","limiter","mainAxisCoord","crossAxisCoord","minSide","maxSide","limitedCoords","limitShift","rawOffset","computedOffset","len","limitMin","limitMax","_middlewareData$offse2","isOriginSide","size","apply","heightSide","widthSide","overflowAvailableHeight","overflowAvailableWidth","noShift","availableHeight","availableWidth","maximumClippingWidth","maximumClippingHeight","xMin","xMax","yMin","yMax","nextDimensions"],"sources":["/Users/mikejabrhamdan/grides-react-app/src/node_modules/@floating-ui/core/dist/floating-ui.core.mjs"],"sourcesContent":["import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const overflowAvailableHeight = height - overflow[heightSide];\n      const overflowAvailableWidth = width - overflow[widthSide];\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isYAxis) {\n        const maximumClippingWidth = width - overflow.left - overflow.right;\n        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        const maximumClippingHeight = height - overflow.top - overflow.bottom;\n        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}